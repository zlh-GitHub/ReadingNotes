# 4.1 值类型转换

将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况；隐式的情况称为强制类型转换（coercion）。

> JavaScript 中的强制类型转换总是返回标量基本类型值（参见第2章），如字符串、数字和布尔值，不会返回对象和函数。

也可以这样来区分：类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时（runtime）。

然而在 JavaScript 中通常将它们统称为强制类型转换，我个人则倾向于用“隐式强制类型转换”（implicit coercion）和“显式强制类型转换”（explicit coercion）来区分。

# 4.2 抽象值操作

介绍显式和隐式强制类型转换之前，我们需要掌握字符串、数字和布尔值之间类型转换的基本规则。ES5 规范第9节中定义了一些“抽象操作”（即“仅供内部使用的操作”）和转换规则。这里我们着重介绍 ToString、ToNumbe r和 ToBoolean，附带讲一讲 ToPrimitive。

## 4.2.1 ToString

负责处理非字符串到字符串的强制类型转换。

基本类型值的字符串化规则为：
* null转换为"null"
* undefined转换为"undefined"
* true转换为"true"
* 数字的字符串化则遵循通用规则，不过第2章中讲过的那些极小和极大的数字使用指数形式
* 对普通对象来说，除非自行定义，否则 toString()（Object.prototype.toString()）返回内部属性 [[Class]] 的值（参见第3章），如 "[object Object]"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。

**将对象强制类型转换为 string 是通过 ToPrimitive 抽象操作来完成的（ES5规范，9.1节）**

数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用", "连接起来

JSON 字符串化

工具函数 JSON.stringify(...) 在将JSON对象序列化为字符串时也用到了 ToString，但并非严格意义上的强制类型转换

所有安全的JSON值（JSON-safe）都可以使用 JSON.stringify(...)字符串化。

> 什么是安全的JSON值（JSON-safe）？安全的JSON值是指能够呈现为有效JSON格式的值。

不安全的JSON值有：

* undefined
* function
* symbol
* 包含循环引用的对象

**JSON.stringify(...) 在对象中遇到 undefined、function 和 symbol 时会自动将其忽略，在数组中则会返回 null（以保证单元位置不变）；遇到包含循环引用的对象则会报错。**例如：

```javascript
JSON.stringify( undefined );      // undefined
JSON.stringify( function(){} );   // undefined

JSON.stringify(
  [1, undefined, function(){},4]
);                                 // "[1, null, null,4]"
JSON.stringify(
  { a:2, b:function(){} }
);                                 // "{"a":2}"
```

**如果对象中定义了 toJSON() 方法，JSON字符串化时会首先调用该方法，然后用它的返回值来进行序列化（注意⚠️是对返回值再进行序列化）。如果要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义 toJSON() 方法来返回一个安全的JSON值。**

不太为人所知但却非常有用的功能：

* 可以向 JSON.stringify(...) 传递一个可选参数 replacer，它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除，和 toJSON() 很像。[具体可查看MDN中对 JSON.stringify 的介绍。](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)

* JSON.stringify 还有一个可选参数 space，用来指定输出的缩进格式。

## 4.2.2 ToNumber

true 转换为1, false 转换为0。undefined 转换为NaN, null 转换为0。

ToNumber 失败时返回NaN（处理数字常量失败时会产生语法错误??? TODO）。对以0开头的十六进制数并不按十六进制处理，而是按十进制。

对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。

为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有 valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。

> 从 ES5 开始，使用 Object.create(null) 创建的对象 [[Prototype]] 属性为 null，并且没有 valueOf() 和 toString() 方法，因此无法进行强制类型转换。否则会报错 `Uncaught TypeError: Cannot convert object to primitive value`

## 4.2.3 ToBoolean

1. 假值（falsy value）

JavaScript 规范具体定义了一小撮可以被强制类型转换为 false 的值。

* undefined
* null
* false
* +0、-0 和 NaN
* ""

**从逻辑上说，假值列表以外的都应该是真值（truthy）。但JavaScript规范对此并没有明确定义**

2. 假值对象（falsy object）

> 假值对象并不是包装了假值的封装对象

值得注意的是，虽然 JavaScript 代码中会出现假值对象，但它实际上并不属于 JavaScript 语言的范畴。

浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来（exotic）值，这些就是“假值对象”。

假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false。最常见的例子是 document.all，它是一个类数组对象，包含了页面上的所有元素，由DOM（而不是JavaScript引擎）提供给 JavaScript 程序使用。它以前曾是一个真正意义上的对象，布尔强制类型转换结果为true，不过现在它是一个假值对象。

> document.all 并不是一个标准用法，早就被废止了。那为什么它要是假值呢？因为我们经常通过将 document.all 强制类型转换为布尔值（比如在 if 语句中）来判断浏览器是否是老版本的 IE。IE 自诞生之日起就始终遵循浏览器标准，较其他浏览器更为有力地推动了 Web 的发展。if(document.all) { /＊ it's IE ＊/ } 依然存在于许多程序中，这对 IE 的用户体验来说不是一件好事。为了让新版本更符合标准，IE并不打算继续支持if (document.all) { .. }。所以通过修改 JavaScript 的类型机制，将 document.all 作为假值来处理

3. 真值（truthy value）

真值就是假值列表之外的值。

# 4.3 显示强制类型转换

## 4.3.1 字符串和数字之间的显式转换

> String(...)、Number(...) 和 Boolean(...) 不通过 new 进行调用时并不创建封装对象

1. `-` 和 `+` 运算符

一元运算符 `+` 可以将字符串显示强制类型转换为数字，也可以将日期（Date）对象强制类型转换为数字（时间戳）

一元运算符 `-` 和 `+` 一样，并且它还会反转数字的符号位。由于 `--` 会被当作递减运算符来处理，所以我们不能使用 `--` 来撤销反转，而应该像 `- -"3.14"` 这样，在中间加一个空格，才能得到正确结果 3.14。

> JavaScript 有一处奇特的语法，即构造函数没有参数时可以不用带()。于是我们可能会碰到 var timestamp = +new Date；这样的写法。这样能否提高代码可读性还存在争议，因为这仅用于new fn()，对一般的函数调用fn()并不适用。

3. `～` 运算符

