常见的原生函数有：

- String()
- Number()
- Boolean()
- Array()
- Object()
- Function()
- RegExp()
- Date()
- Error()
- Symbol()
- Map()
- Set()

原生函数可以被当作构造函数来使用，但其构造出来的对象可能会和我们设想的有所出入：

```javascript
const s1 = new String("js");
const s2 = "js";
console.log(typeof s1); // "object"
console.log(Object.prototype.toString.call(s1)); // "[object String]"
console.log(s1 instanceof String); // true
console.log(s2 instanceof String); // false
```

通过构造函数（如 new String("abc")）创建出来的是封装了基本类型值（如"abc"）的封装对象。请注意：typeof 在这里返回的是对象类型的子类型。

# 3.1 内部属性[[class]]

所有 typeof 返回值为 "object" 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(...) 来查看。

多数情况下，对象的内部 [[Class]] 属性和创建该对象的内建原生构造函数相对应（如下），但并非总是如此。

```javascript
Object.prototype.toString.call(null);
// "[object Null]"

Object.prototype.toString.call(undefined);
// "[object Undefined]"
```

虽然 Null() 和 Undefined() 这样的原生构造函数并不存在，但是内部 [[Class]] 属性值仍然是 "Null" 和 "Undefined"。

其他基本类型值（如字符串、数字和布尔）的情况有所不同，通常称为“包装”（boxing，参见3.2节）：

```javascript
Object.prototype.toString.call( "abc" );
// "[object String]"

Object.prototype.toString.call( 42 );
// "[object Number]"

Object.prototype.toString.call( true );
// "[object Boolean]"
```

上例中基本类型值被各自的封装对象自动包装，所以它们的内部 [[Class]] 属性值分别为 "String"、"Number" 和 "Boolean"。

> 从 ES5 到 ES6, toString() 和 [[Class]] 的行为发生了一些变化，详情见本系列的《你不知道的JavaScript（下卷）》的“ES6 & Beyond”部分。TODO

# 3.2 封装对象包装

封装对象（object wrapper）扮演着十分重要的角色。由于基本类型值没有 `.length` 和 `.toString()` 这样的属性和方法，需要通过封装对象才能访问，此时 JavaScript 会自动为基本类型值包装（box或者wrap）一个封装对象

> 那如果需要经常用到这些字符串属性和方法，比如在 for 循环中使用 i < a.length，那么从一开始就创建一个封装对象也许更为方便，这样 JavaScript 引擎就不用每次都自动创建了？

但实际证明这并不是一个好办法，因为浏览器已经为 `.length` 这样的常见情况做了性能优化，直接使用封装对象来“提前优化”代码反而会降低执行效率。一般情况下，我们不需要直接使用封装对象。最好的办法是让 JavaScript 引擎自己决定什么时候应该使用封装对象。换句话说，就是应该优先考虑使用 "abc" 和 42 这样的基本类型值，而非 new String("abc") 和 new Number(42)。

使用封装对象的注意事项：

比如 Boolean

```javascript
var a = new Boolean( false );

if (! a) {
    console.log( "Oops" ); // 执行不到这里
}
```

我们为 false 创建了一个封装对象，然而该对象是真值（“truthy”，即总是返回true），所以这里使用封装对象得到的结果和使用 false 截然相反。

如果想要自行封装基本类型值，可以使用 Object(..) 函数（不带 new 关键字）：

```javascript
var a = "abc";
var b = new String( a );
var c = Object( a );

typeof a; // "string"
typeof b; // "object"
typeof c; // "object"

b instanceof String; // true
c instanceof String; // true

Object.prototype.toString.call( b ); // "[object String]"
Object.prototype.toString.call( c ); // "[object String]"
```

再次强调，一般不推荐直接使用封装对象

# 3.3 拆封

如果想要得到封装对象中的基本类型值，可以使用 `valueOf()` 函数。

在需要用到封装对象中的基本类型值的地方会发生隐式拆封。具体过程（即强制类型转换）将在第4章详细介绍。

# 3.4 原生函数作为构造函数

## 3.4.1 Array(...)

关于数组（array）、对象（object）、函数（function）和正则表达式，我们通常喜欢以常量的形式来创建它们。实际上，使用常量和使用构造函数的效果是一样的（创建的值都是通过封装对象来包装）。

应该尽量避免使用构造函数，除非十分必要，因为它们经常会产生意想不到的结果。

> 例如？TODO

构造函数 Array(..) 不要求必须带new关键字。不带时，它会被自动补上。

Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。但是数组并没有预设长度这个概念。这样创建出来的是一个空数组，只不过它的 length 属性被设置成了指定的值。

如若一个数组没有任何单元，但它的 length 属性中却显示有单元数量，这样奇特的数据结构会导致一些怪异的行为。而这一切都归咎于已被废止的旧特性（类似arguments这样的类数组）。

> 包含至少一个“空单元”的数组称为“稀疏数组”。

不同浏览器的开发控制台对稀松数组对显示的结果不尽相同，以 Chrome 108.0.5359.124（正式版本） (arm64) 为例

```javascript
var a = new Array( 3 );
var b = [ undefined, undefined, undefined ];
var c = [];
c.length = 3;

a; // [empty x 3]
b; // [undefined, undefined, undefined]
c; // [empty x 3]
```

除了上述的显示，稀松数组还可能显示成下面的形式

```javascript
[undefined x 3]
[,,,]
Array [<3 empty slots>]
```

> 为什么存在 length 为3却有3个逗号？

原因是从 ES5 规范开始就允许在列表（数组值、属性列表等）末尾多加一个逗号（在实际处理中会被忽略不计）。所以如果你在代码或者调试控制台中输入[ , , ,]，实际得到的是[ , , ]（包含三个空单元的数组）。

除了 Array 传递一个数字参数和通过修改 length属性隐式制造空单元外，还可以通过 delete 运算符在数组中制造出一个空单元出来

稀松数组行为在某些情况与正常数据大相径庭，如下；

```javascript
const a = new Array(3);
const b = [undefined, undefined, undefined];
a.join( "-" ); // "--"
b.join( "-" ); // "--"

a.map(function(v, i){ return i; }); // [ undefined x 3 ]
b.map(function(v, i){ return i; }); // [ 0, 1, 2 ]
```

a.map(...) 之所以执行失败，是因为数组中并不存在任何单元，所以 map(...) 无从遍历。而 join(...) 却不一样，它的具体实现可参考下面的代码：

```javascript
function fakeJoin(arr, connector) {
  let str = '';
  for (let i = 0; i < arr.length; i++>) {
    if (i > 0) {
      str += connector;
    }
    if (arr[i] !== undefined) {
      str += arr[i];
    }
  }
  return str;
}
```

> 如何快速创建包含 undefined 单元（而非“空单元”）的纯稀松数组？

```javascript
const a = Array.apply(null, { length: 3 }); // 等于 Array(undefined, undefined, undefined)
```

为什么会产生这样的效果，具体可看 apply 的源码(TODO)

**结论：永远不要创建和使用空单元数组**

## 3.4.2 Object(...)、Function(...)和RegExp(...)

**除非万不得已，否则尽量不要使用 Object(...) / Function(...) / RegExp(...)：**

构造函数 Function 只在极少数情况下很有用，比如动态定义函数参数和函数体的时候

> Function(...) 和 eval(...)的比较

**强烈建议使用常量形式（如/^a＊b+/g）来定义正则表达式，这样不仅语法简单，执行效率也更高，因为 JavaScript 引擎在代码执行前会对它们进行预编译和缓存。** 与前面的构造函数不同，RegExp(...) 有时还是很有用的，比如动态定义正则表达式时。

## 3.4.3 Date(...)和Error(...)

如果调用 Date() 时不带 new 关键字，则会得到当前日期的字符串值。其具体格式规范没有规定。

构造函数 Error(...) 也可以不带 new 关键字调用。创建错误对象（error object）主要是为了获得当前运行栈的上下文（大部分 JavaScript 引擎通过只读属性 `.stack` 来访问）。栈上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试（debug）。

错误对象常用属性：
* message
* stack

> 除Error(...) 之外，还有一些针对特定错误类型的原生构造函数，如 EvalError(...)、RangeError(...)、 ReferenceError(...)、 SyntaxError(...)、TypeError(...) 和 URIError(...)。这些构造函数很少被直接使用，它们在程序发生异常（比如试图使用未声明的变量产生 ReferenceError 错误）时会被自动调用。

## 3.4.4 Symbol(..)

Symbol(...) 构造函数不能使用 new 关键字调用。

符号并非对象，而是一种简单标量基本类型。

# 3.4.5 原生原型

有些原生原型（native prototype）并非普通对象那么简单：

```javascript
typeof Function.prototype;          // "function"
Function.prototype();               // 空函数！

RegExp.prototype.toString();        // "/(? :)/"——空正则表达式
"abc".match( RegExp.prototype );    // [""]
```

更糟糕的是，我们甚至可以修改它们（而不仅仅是添加属性）：

```javascript
Array.isArray( Array.prototype );   // true
Array.prototype.push( 1, 2, 3 );    // 3
Array.prototype;                    // [1,2,3]

// 需要将Array.prototype设置回空，否则会导致问题！
Array.prototype.length = 0;
```

Function.prototype 是一个空函数，RegExp.prototype 是一个“空”的正则表达式（无任何匹配），而 Array.prototype 是一个空数组。对未赋值的变量来说，它们是很好的默认值。这种方法的一个好处是 prototype 已被创建并且仅创建一次。相反，如果将 []、function(){} 和 /(? :)/ 作为函数参数默认值，则每次调用、它们都会被创建一次（具体创建与否取决于JavaScript引擎，稍后它们可能会被垃圾回收），这样无疑会造成内存和CPU资源的浪费。