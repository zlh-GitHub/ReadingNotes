# 1.2 内置类型

JavaScript 有七种内置类型
* 空值 null
* 未定义 undefined
* 布尔值 boolean
* 数字 number
* 字符串 string
* 对象 object
* 符号 symbol（ES6种新增）

除对象外，其他统称为“基本类型”。

我们可以用 typeof 运算符来查看值类型，它返回的是类型的字符串的值。有意思的是，这七种类型的和它们的字符串值并不一一对应。


```javascript
console.log(typeof null); // "object"
```

null 是个例外。它比较特殊，typeof 对它的处理有问题，正确的返回结果应该是 "null"，但这个 bug 由来已久，在 JavaScript 中已经存在了将近二十年，也许永远也不会修复，因为这牵涉到太多的 Web 系统，“修复”它会产生更多的 bug，令许多系统无法正常工作。

> 原理：不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回 “object” —— 《你不知道的JavaScript 上卷》第二部分 第三章对象 3.2类型 注1 P103

function（函数）也是 JavaScript 的一个内置类型。然而查阅规范就会知道，它实际上是 object 的一个“子类型”（像 array 等也都是属于 object 的一个 “子类型”）。具体来说，函数是“可调用对象”，它有一个内部属性 [[Call]]，该属性使其可以被调用。既然函数是对象，那么函数自然也可以有属性

```javascript
function a(b, c) {
  /** */
}
console.log(a.length); // 2
```

函数对象的 length 属性是其声明的参数的个数

> 番外：函数（非箭头函数）内部有一个 arguments 对象，其也有一个 length 属性，但是该 length 属性表示的是函数执行时实参的个数。

> 番外：箭头函数没有 arguments 对象的原理，当函数初始化的时候,如果是箭头函数，会设置内部属性 [[ThisMode]] 为 lexical，这决定了当创建函数上下文的时候创不创建 arguments 对象

# 1.3 值和类型

JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。

在对变量执行 typeof 操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型，因为 JavaScript 中的变量没有类型。

大多数开发者倾向于将 undefined 等同于 undeclared（未声明），但在JavaScript 中它们完全是两回事。已在作用域中声明但还没有赋值的变量，是undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared的。

```javascript
var a;

a; // undefined
b; // ReferenceError: b is not defined
```

对于 undeclared（或者not defined）变量，typeof 照样返回 "undefined"。这是因为 typeof 有一个特殊的安全防范机制。

该安全防范机制对在浏览器中运行的JavaScript代码来说还是很有帮助的，如 DEBUG 为全局变量，为其他 JS 文件声明：

```javascript
// 这样会抛出错误
if (DEBUG) {
  // 使用 window.DEBUG 可以解决，因为访问不存在的对象属性不会产生ReferenceError错误。
  console.log( "Debugging is starting" );
}

// 这样是安全的
if (typeof DEBUG ! == "undefined") {
  console.log( "Debugging is starting" );
}
```

> 如果在 if 语句中使用 var，声明会被提升 —— 参见《你不知道的JavaScript（上卷）》中的“作用域和闭包”部分