# 2.1 数组

> 使用 delete 运算符可以将单元从数组中删除，但是请注意，单元删除后，数组的 length 属性并不会发生变化。第 5 章将详细介绍 delete 运算符。 TODO

“稀疏”数组（sparse array，即含有空白或空缺单元的数组）

```javascript
const a = [];

a[0] = 1;
// 此处没有设置a[1]单元
a[2] = [3];

a[1]; // undefined

a.length; // 3
```

上面的代码可以正常运行，但其中的“空白单元”（empty slot）可能会导致出人意料的结果。a[1] 的值为 undefined ，但这与将其显式赋值为 undefined（a[1] = undefined）还是有所区别。详情请参见 3.4.1 节。TODO

类数组（arrayLike）：一些 DOM 查询操作会返回 DOM 元素列表，它们并非真正意义上的数组，但十分类似。另一个例子是通过 arguments 对象（类数组）将函数的参数当作列表来访问（从 ES6 开始已废止）

类数组转换为真正的数组常用的方式：

1. Array.prototype.slice.call(arrayLike)
2. Array.from(arrayLike)

# 2.2 字符串

字符串也是类数组。JavaScript 中字符串是不可变的，而数组是可变的。字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。

小技巧

```javascript
a.join; // undefined
a.map; // undefined

const c = Array.prototype.join.call(a, "-");
const d = Array.prototype.map
  .call(a, function (v) {
    return v.toUpperCase() + ".";
  })
  .join("");

c; // "f-o-o"
d; // "F.O.O."
```

# 2.3 数字

## 2.3.1 数字的语法

JavaScript 只有一种数值类型：number（数字），包括“整数”和带小数的十进制数。此处“整数”之所以加引号是因为和其他语言不同，JavaScript 没有真正意义上的整数。

与大部分现代编程语言（包括几乎所有的脚本语言）一样，JavaScript 中的数字类型是基于 IEEE 754 标准来实现的，该标准通常也被称为“浮点数”。JavaScript 使用的是“双精度”格式（即 64 位二进制）。

小数点前面的 0 和小数点最后面的 0 都可以忽略，如：

```javascript
const a = 0.42;
const b = 0.42;

const c = 42.0;
const d = 42;
```

特别大和特别小的数字默认用指数格式显示，与 toExponential() 函数的输出结果相同

```javascript
const a = 5E10;
a;                  // 50000000000
a.toExponential();  // "5e+10"

const b = a ＊ a;
b;                  // 2.5e+21

const c = 1 / a;
c;                  // 2e-11
```

常用方法：

- tofixed() 指定小数部分的显示位数
- toPresision() 指定小数部分的显示位数

**上面的方法不仅适用于数字变量，也适用于数字字面量。不过对于．运算符需要给予特别注意，因为它是一个有效的数字字符，会被优先识别为数字字面量的一部分，然后才是对象属性访问运算符。**

```javascript
// 无效语法：
42.toFixed( 3 );    // SyntaxError

// 下面的语法都有效：
(42).toFixed( 3 );  // "42.000"
0.42.toFixed( 3 );  // "0.420"
42..toFixed( 3 );   // "42.000"
42 .toFixed(3);     // "42.000"
```

我们还可以用指数形式来表示较大的数字，如：

```javascript
const onethousand = 1e3; // 即 1 ＊ 10^3
const onemilliononehundredthousand = 1.1e6; // 即 1.1 ＊ 10^6
```

二进制、八进制和十六进制

```javascript
0xf3; // 243的十六进制
0xf3; // 同上

0363; // 243的八进制
```

从 ES6 开始，严格模式（strict mode）不再支持 0363 八进制格式（新格式如下）。0363 格式在非严格模式（non-strict mode）中仍然受支持，但是考虑到将来的兼容性，最好不要再使用（我们现在使用的应该是严格模式）。

ES6 支持以下新格式：

```javascript
0o363; // 243的八进制
0o363; // 同上

0b11110011; // 243的二进制
0b11110011; // 同上
```

**考虑到代码的易读性，不推荐使用 0O363 格式，因为 0 和大写字母 O 在一起容易混淆。建议尽量使用小写的 0x、0b 和 0o。**

## 2.3.2 较小的数值

二进制浮点数最大的问题（不仅 JavaScript ，所有遵循 IEEE 754 规范的语言都是如此），是会出现如下情况：

```javascript
conosle.log(0.1 + 0.2 === 0.3); // false
console.log(0.1 + 0.2); // 0.30000000000000004
```

> 有人认为，JavaScript 应该采用一种可以精确呈现数字的实现方式。一直以来出现过很多替代方案，只是都没能成为标准，以后大概也不会。这个问题看似简单，实则不然，否则早就解决了。

在处理带有小数的数字时需要特别注意。很多（也许是绝大多数）程序只需要处理整数，最大不超过百万或者万亿，此时使用 JavaScript 的数字类型是绝对安全的。

那么应该怎样来判断 0.1 + 0.2 和 0.3 是否相等呢？

最常见的方法是设置一个误差范围值，通常称为“机器精度”（machine epsilon），对 JavaScript 的数字来说，这个值通常是 2^-52(2.220446049250313e-16)。

从 ES6 开始，该值定义在 Number.EPSILON 中

```javascript
if (!Number.EPSILON) {
  Number.EPSILON = Math.pow(2, -52);
}

const numberCloseEnoughToEqual = (n1, n2) => {
  return Math.abs(n1 - n2) < Number.EPSILON;
};
```

能够呈现的最大浮点数大约是 1.798e+308（这是一个相当大的数字），它定义在 Number.MAX_VALUE 中。最小浮点数定义在 Number.MIN_VALUE 中，大约是 5e-324 ，它不是负数，但无限接近于 0！

## 2.3.3 整数的安全范围

能够被“安全”呈现的最大整数是 2^53-1，即 9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是 -9007199254740991，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER。

有时 JavaScript 程序需要处理一些比较大的数字，如数据库中的 64 位 ID、商城订单号等。由于 JavaScript 的数字类型无法精确呈现 64 位数值，所以必须将它们保存（转换）为字符串。

## 2.3.4 整数检测

常用方法

- Number.isInteger()

```javascript
if (!Number.isInteger) {
  Number.isInteger = function (num) {
    return typeof num == "number" && num % 1 == 0;
  };
}
```

- Number.isSafeInteger()

```javascript
if (!Number.isSafeInteger) {
  Number.isSafeInteger = function (num) {
    return Number.isInteger(num) && Math.abs(num) <= Number.MAX_SAFE_INTEGER;
  };
}
```

## 2.3.5 32 位有符号整数

虽然整数最大能够达到 53 位，但是有些数字操作（如数位操作）只适用于 32 位数字。

`a | 0` 可以将变量 a 中的数值转换为 32 位有符号整数，因为数位运算符 `|` 只适用于 32 位整数（它只关心 32 位以内的值，其他的数位将被忽略）。因此与 0 进行 OR 操作本质上没有意义。

某些特殊的值并不是 32 位安全范围的，如 NaN 和 Infinity，此时会对它们执行虚拟操作（abstract operation）ToInt32（参见第 4 章），以便转换为符合数位运算符要求的+0 值。

# 2.4 特殊数值

## 2.4.1 不是值的值

undefine d 类型只有一个值，即 undefined。null 类型也只有一个值，即 null。它们的名称既是类型也是值。

undefined 和 null 常被用来表示“空的”值或“不是值”的值。二者之间有一些细微的差别。例如：

- null 指空值（empty value）
- undefined 指没有值（missing value）

或者：

- undefined 指从未赋值
- null 指曾赋过值，但是目前没有值

> 这种细微的差别很重要，最常出现错误的地方就是对象的解构赋值，null 会被当作一个值，而导致默认值不生效

```javascript
const obj = {
  a: undefined,
  b: null,
  c: "c",
};

const { a = "A", b = "B", c = "C" } = obj;

console.log(a, b, c); // A null c
```

**null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而 undefined 却是一个标识符，可以被当作变量来使用和赋值。**

## 2.4.2 undefined

在非严格模式下，我们可以为全局标识符 undefined 赋值

```javascript
function foo() {
  undefined = 2; // 非常糟糕的做法！
}

foo();

function foo() {
  "use strict";
  undefined = 2; // TypeError!
}

foo();
```

在非严格和严格两种模式下，我们可以声明一个名为 undefined 的局部变量。**最好不要这样做！永远不要重新定义 undefined。**

```javascript
function foo() {
  "use strict";
  var undefined = 2;
  console.log(undefined); // 2
}

foo();
```

### void 运算符

undefined 是一个内置标识符（除非被重新定义），它的值为 undefined，通过 void 运算符即可得到该值。

表达式 void \_\_ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值

按惯例我们用 void 0 来获得 undefined（这主要源自 C 语言，当然使用 void true 或其他 void 表达式也是可以的）。void 0、void 1 和 undefined 之间并没有实质上的区别。

void 运算符在其他地方也能派上用场，比如不让表达式返回任何结果（即使其有副作用）。

```javascript
if (!APP.ready) {
  // 稍后再试
  setTimeout(doSomething, 100);
  return;
}

// 可改为

if (!APP.ready) {
  // 稍后再试
  return void setTimeout(doSomething, 100);
}
```

## 2.4.3 特殊的数字

1. 不是数字的数字

如果数学运算的操作数不是数字类型（或者无法解析为常规的十进制或十六进制数字），就无法返回一个有效的数字，这种情况下返回值为 NaN 。

NaN 意指“不是一个数字”（not a number），这个名字容易引起误会，后面将会提到。将它理解为“无效数值”“失败数值”或者“坏数值”可能更准确些。

```javascript
var a = 2 / "foo"; // NaN

typeof a === "number"; // true
```

NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。

**NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值**

```javascript
console.log(NaN == NaN); // false
console.logg(NaN === NaN); // false

console.log(NaN != NaN); // true
console.log(NaN !== NaN); // true
```

如何判断值是否为 NaN ？

1. window.isNaN()
2. Number.isNaN()

window.isNaN(..) 有一个严重的缺陷，它的检查方式过于死板，就是“检查参数是否不是 NaN，也不是数字”。但是这样做的结果并不太准确：

```javascript
var a = 2 / "foo";
var b = "foo";

a; // NaN
b; // "foo"

window.isNaN(a); // true
window.isNaN(b); // true
```

所以建议使用 Number.isNaN()

```javascript
// polyfill
if (!Number.isNaN) {
  Number.isNaN = function (n) {
    return typeof n === "number" && window.isNaN(n);
  };
}

var a = 2 / "foo";
var b = "foo";

Number.isNaN(a); // true
Number.isNaN(b); // false

// 亦或者

if (!Number.isNaN) {
  Number.isNaN = function (n) {
    return n !== n;
  };
}
```

2. 无穷数

- Infinity 即 Number.POSITIVE_INfINITY
- -Infinity 即 Number.NEGATIVE_INfINITY

JavaScript 使用有限数字表示法（finite numeric representation，即之前介绍过的 IEEE 754 浮点数），所以和纯粹的数学运算不同，JavaScript 的运算结果有可能溢出，此时结果为 Infinity 或者 -Infinity。

```javascript
var a = Number.MAX_VALUE; // 1.7976931348623157e+308
a + a; // Infinity
a + Math.pow(2, 970); // Infinity
a + Math.pow(2, 969); // 1.7976931348623157e+308

var b = 1 / 0; // Infinity
var c = -1 / 0; // -Infinity
```

规范规定，如果数学运算（如加法）的结果超出处理范围，则由 IEEE 754 规范中的“就近取整”（round-to-nearest）模式来决定最后的结果。例如，相对于 Infinity, Number.MAX VALUE + Math.pow(2, 969) 与 Number.MAX_VALUE 更为接近，因此它被“向下取整”（round down）；而 Number.MAX VALUE + Math.pow(2, 970) 与 Infinity 更为接近，所以它被“向上取整”（round up）。

**计算结果一旦溢出为无穷数（infinity）就无法再得到有穷数。换句话说，就是你可以从有穷走向无穷，但无法从无穷回到有穷。**

> 无穷除以无穷会得到什么结果呢？

我们的第一反应可能会是“1”或者“无穷”，可惜都不是。因为从数学运算和 JavaScript 语言的角度来说，Infinity/Infinity 是一个未定义操作，结果为 NaN。

> 有穷正数除以 Infinity 呢？

很简单，结果是 0。

> 有穷负数除以 Infinity 呢？

TODO

3. 零值

JavaScript 有一个常规的 0（也叫作`+0`）和一个 `-0`。

加法和减法运算不会得到负零（negative zero）。

负零在开发调试控制台中通常显示为-0，但在一些老版本的浏览器中仍然会显示为 0。

根据规范，对负零进行字符串化会返回"0"：

```javascript
var a = 0 / -3;

// 至少在某些浏览器的控制台中显示是正确的
a; // -0

// 但是规范定义的返回结果是这样！
a.toString(); // "0"
a + ""; // "0"
String(a); // "0"

// JSON也如此，很奇怪
JSON.stringify(a); // "0"
```

有意思的是，如果反过来将其从字符串转换为数字，得到的结果是准确的：

```javascript
+"-0"; // -0
Number("-0"); // -0
JSON.parse("-0"); // -0
```

负零转换为字符串的结果令人费解，它的比较操作也是如此：

```javascript
-0 == 0; // true

a === b; // true
-0 === 0; // true

0 > -0; // false
a > b; // false
```

## 2.4.4 特殊等式

> 如何判断一个值是不是-0（negative zero）?

可以使用 Object.is(...)。能使用 == 和 ===（时就尽量不要使用 Object.is(..)，因为前者效率更高、更为通用。Object.is(..)主要用来处理那些特殊的相等比较。

```javascript
function isNegativeZero(n) {
  n = Number(n);
  return n === 0 && 1 / n === -Infinity;
}
```

```javascript
// polyfill
if (!Object.is) {
  Object.is = function (v1, v2) {
    if (v1 === 0 && v2 === 0) {
      return 1 / v1 === 1 / v2;
    }
    // NaN
    if (v1 !== v1) {
      return v2 !== v2;
    }
    // 其他情况
    return v1 === v2;
  };
}
```

# 2.5 值和引用

JavaScript 中没有指针，引用的工作机制也不尽相同。在 JavaScript 中变量不可能成为指向另一个变量的引用。

简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值/传递，包括 null、undefined、字符串、数字、布尔和 ES6 中的 symbol。**标量基本类型值是不可更改的。**

复合值（compound value）——对象（包括数组和封装对象，参见第 3 章）和函数，则总是通过引用复制的方式来赋值/传递。

请记住：我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。

```javascript
var a = 2;
var b = a; // b是a的值的一个复本
b++; // b更改时，a的值保持不变
a; // 2
b; // 3

var c = [1, 2, 3];
var d = c; // d是[1,2,3]的一个引用，和c均指向同一个复合值
d.push(4);
c; // [1,2,3,4]
d; // [1,2,3,4]
```

由于引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向。如：

```javascript
var a = [1, 2, 3];
var b = a;
a; // [1,2,3]
b; // [1,2,3]

// 然后
b = [4, 5, 6];
a; // [1,2,3]
b; // [4,5,6]
```
